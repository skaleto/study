Design Pattern

六大原则

    单一职责原则
        一个类仅有一个职责，引起类变化的只有一个原因
        
    里氏替换原则
        所有引用基类的地方都必须能够透明的使用其子类的对象。也就是说，但凡父类能出现的地方，子类就可以出现，而且替换为子类不会产生任何错误或者异常。
        但是，反过来就不行了，有子类出现的地方，父类未必就能适应。

        
    依赖倒置原则
        高层模块不应该依赖低层模块，两者都应该依赖其抽象：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
        抽象（接口或抽象类）不应该依赖细节：接口或抽象类不依赖于实现类；
        细节（实现类）应该依赖抽象：实现类依赖接口或抽象类。
        高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。

    接口隔离原则
        不应该依赖不需要的接口；
        类间的依赖应该建立在最小的接口上面；

    
    迪米特原则
        也称为最少知识原则，一个对象应该对其他对象有最少的了解
        通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少

    开闭原则
        一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。


单例模式

    确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例
    
    懒汉式：仅在第一次被创建时生成一个实例；但存在线程安全问题，需要加锁保证只会生成一个实例；
    饿汉式：在类被加载时都立刻生成实例；
    
工厂模式

简单工厂：

    提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类
    
工厂方法：

    提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。
    
抽象工厂：
    
    为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。
    
抽象工厂模式与工厂方法模式的区别：
    
    抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。
    
    如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。 



建造者模式

    将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
    关键词：复杂对象
    建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成
    
    
策略模式

    定义一组算法，将每个算法都封装起来，并且使它们之间可以互换

    Context封装角色它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。
    Strategy抽象策略角色策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。
    ConcreteStrategy具体策略角色实现抽象策略中的操作，该类含有具体的算法。

观察者模式

    定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新
    
    Subject：定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。
    Observer观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。
    ConcreteSubject定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。
    ConcreteObserver每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。
    
模板方法模式

    定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
    简单说就是把一些规定好的不能修改的东西放在基类中，设置为final，把其中可以修改或者容易改变的东西交给子类来实现
    
代理模式

    为其他对象提供一种代理以控制对这个对象的访问
    
    ● Subject抽象主题角色
    抽象主题类可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求。
    ● RealSubject具体主题角色
    也叫做被委托角色、被代理角色。它才是冤大头，是业务逻辑的具体执行者。
    ● Proxy代理主题角色
    也叫做委托类、代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。

    ● 普通代理和强制代理：
    普通代理就是我们要知道代理的存在，也就是类似的GamePlayerProxy这个类的存在，然后才能访问；
    强制代理则是调用者直接调用真实角色，而不用关心代理是否存在，其代理的产生是由真实角色决定的。
    普通代理：
    在该模式下，调用者只知代理而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色想怎么修改就怎么修改，对高层次的模块没有任何的影响，只要你实现了接口所对应的方法，该模式非常适合对扩展性要求较高的场合。
     
    ● 强制代理：
    强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色。高层模块只要调用getProxy就可以访问真实角色的所有方法，它根本就不需要产生一个代理出来，代理的管理已经由真实角色自己完成。
     
    ● 动态代理：
    根据被代理的接口生成所有的方法，也就是说给定一个接口，动态代理会宣称“我已经实现该接口下的所有方法了”。
    两条独立发展的线路。动态代理实现代理的职责，业务逻辑Subject实现相关的逻辑功能，两者之间没有必然的相互耦合的关系。通知Advice从另一个切面切入，最终在高层模块也就是Client进行耦合，完成逻辑的封装任务。
     
    动态代理调用过程示意图：
    动态代理的意图：横切面编程，在不改变我们已有代码结构的情况下增强或控制对象的行为。 
    首要条件：被代理的类必须要实现一个接口。
    
    为什么要用代理模式？
    中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。
    开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。
    代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。


动态代理

    动态代理的话是在实现阶段不需要关心代理谁，在运行阶段会动态生成一个代理类去代理指定的对象
    
    需要用到reflect包下的Proxy
    Proxy.newProxyInstance()方法接受三个参数：
    
    ClassLoader loader:指定当前目标对象使用的类加载器,获取加载器的方法是固定的
    Class<?>[] interfaces:指定目标对象实现的接口的类型,使用泛型方式确认类型
    InvocationHandler:指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法  
    
    
CGLIB代理

    JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了
    虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。
    回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。
    有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。
    如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。  
    
    CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。

    Cglib动态代理执行代理方法效率之所以比JDK的高是因为Cglib采用了FastClass机制，它的原理简单来说就是：为代理类和被代理类各生成一个Class，这个Class会为代理类或被代理类的方法分配一个index(int类型)。
    这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。
    
    延伸：
    ASM字节码生成框架https://blog.csdn.net/xysmiracle/article/details/38293795


装饰者模式

    代理模式使用到极致开发就是AOP， 这是各位采用Spring架构开发必然要使用到的技术(Spring学习之第一个AOP程序)，它就是使用了代理和反射的技术。代理模式在Java的开发中俯拾皆是， 是大家非常熟悉的模式， 应用非常广泛， 而装饰模式是一个比较拘谨的模式， 在实际应用中接触比较少， 但是也有不少框架项目使用了装饰模式， 例如在JDK的java.io.*包中就大量使用装饰模式， 类似如下的代码：

    装饰模式是在不使用继承和不改变原类文件的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
     1.不改变原类文件。
     2.不使用继承。
     3.动态扩展。
     
    OutputStream out = new DataOutputStream（ new FileOutputStream（ "test.txt"） ）    
    这是装饰模式的一个典型应用， 使用DataOutputStream封装了一个FileOutputStream， 以方便进行输出流处理。
    
      1） Component（抽象组件又叫被装饰对象的基类）
    
                 定义一个对象接口，可以给这些对象动态地添加职责。
    
      2） ConcreteComponent（具体组件又叫具体被装饰对象）
    
                定义一个对象，可以给这个对象添加一些职责。
    
      3） Decorator（装饰者抽象类）
    
               维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。
    
      4）ConcreteDecorator（具体装饰者）
    
               具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。
    
适配器模式




 











